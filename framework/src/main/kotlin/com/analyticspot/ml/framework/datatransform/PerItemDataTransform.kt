package com.analyticspot.ml.framework.datatransform

import com.analyticspot.ml.framework.dataset.DataSet
import com.analyticspot.ml.framework.dataset.IterableDataSet
import com.analyticspot.ml.framework.description.IndexValueToken
import com.analyticspot.ml.framework.description.TransformDescription
import com.analyticspot.ml.framework.description.ValueId
import com.analyticspot.ml.framework.description.ValueIdGroup
import com.analyticspot.ml.framework.description.ValueToken
import com.analyticspot.ml.framework.description.ValueTokenGroup
import com.analyticspot.ml.framework.description.ValueTokenGroupFromList
import com.analyticspot.ml.framework.observation.ArrayObservation
import com.analyticspot.ml.framework.observation.Observation
import java.util.concurrent.CompletableFuture

/**
 * Base class for a [DataTransform] that operates on a single value of the input data at a time. By using this base
 * class you can write code that operates just on single values but have the transform applied to whole [ValueIdGroup].
 *
 * The [ValueToken] generated by this transform have the same names as the corresponding token in the input - only the
 * type changes.
 *
 * @param <InputT> the type of data this operates on.
 * @param <OutputT> the type of data produced by this transform.
 *
 * @param srcGroupTok the values to which this transform should be applied. The transform will be applied to each of the
 *    columns specified by the [ValueTokenGroup].
 * @param resultId the [ValueIdGroup] for the values produced by this transform.
 * @param resultClass the type of the result.
 */
abstract class PerItemDataTransform<InputT, out OutputT : Any>(
        private val srcGroupTok: ValueTokenGroup<InputT>,
        resultId: ValueIdGroup<OutputT>,
        private val resultClass: Class<OutputT>) : SingleDataTransform {
    private val tokenGroupAndSetter = ValueTokenGroupFromList.create(resultId)
    override val description: TransformDescription =
            TransformDescription(listOf(), listOf(tokenGroupAndSetter.tokenGroup))

    override fun transform(dataSet: DataSet): CompletableFuture<DataSet> {
        // Compute the new values
        val srcTokens = srcGroupTok.tokens()
        val resultIter: Iterable<Observation> = dataSet.map { obs ->
            val row: List<OutputT> = srcTokens.map { transform(obs.value(it)) }
            ArrayObservation(row)
        }

        // Create the tokens for the computed values.
        val newTokens = srcGroupTok.tokens().mapIndexed { idx, valueToken ->
            val newValId = ValueId(valueToken.name, resultClass)
            IndexValueToken<OutputT>(idx, newValId)
        }
        tokenGroupAndSetter.setter(newTokens)

        return CompletableFuture.completedFuture(IterableDataSet(resultIter))
    }

    abstract fun transform(input: InputT): OutputT
}
